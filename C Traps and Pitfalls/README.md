# 第１章　词法“陷阱”
## 1.1 ＝不同于＝＝
## 1.2 &和|不同于&&和||
## 1.3 词法分析中的“贪心法”
## 1.4　整形变量
０开头，八进制
## 1.５　字符与字符串
‘’和“”
# 第２章　语法“陷阱”
必须理解这些符号是如何组合成声明、表达式、语句和程序的
## 2.1 理解函数声明
```c
(*(void(*)())0)();

typedef void (*funcptr)();
(*(funcptr)0)();

void (*singnal(int, void(*)(int)))(int);

typedef void (*HANDLER)(int);
HANDLER singal(int, HANDLER);

```
## 2.2 运算符的优先级问题
* 非真正意义运算符
* 单目
* 双目（算术、移位、关系、逻辑，赋值、条件）
* 三目
* 赋值
* 逗号

## 2.3 注意作为语句结束标志的分号
多写，少写
## 2.4 switch语句
break，或有意略去
## 2.5 函数调用
不带参数也该有参数列表，否则只是计算地址
## 2.6 “悬挂”else引发的问题
else始终与同一括号内最近的未匹配的if结合
# 第３章　语义“陷阱”
语法歧义
## 3.1 指针与数组
* 只有一维数组，且数组大小必须在编译器就作为一个常数确定下来
* 只能做两件事：确定大小，获取[0]指针
* 指针＋整数，与该指针的二进制＋整数，含义不同
* int (*ap)[31];

## 3.2 非数组的指针
以空字符串('\0')作为结束标志
```c
char *r, *malloc();
r = malloc(strlen(s) + strlen(t) + 1);
if(!r) {
	complain();
	exit(1);
}
strcpy(r, s);
strcat(r, t);
```
## 3.3 作为参数的数组声明
无法将数组作为函数参数直接传递
## 3.4 避免“举隅法”
复制指针并不同时复制指针所指向的数据
## 3.5 空指针并非空字符串
```c
if (p == (char *)0) ...// OK

if (strcmp(p, (char *) == 0) ... // ERROR
```
## 3.6 边界计算与不对称边界
10个元素数组，不存在下标为10的元素

避免"栏杆错误"的两个通用原则
1. 首先考虑最简单情况下的特例，然后将得到的结果外推
2. 仔细计算边界，绝不掉以轻心

ANSI　C标准明确允许这种用法:数组中实际不存在的"溢界"元素的地址位于数组所占内存之后，这个地址可以用于进行赋值和比较。当然，如果要引用该元素，那就是非法的了

## 3.7 求值顺序
```c
if (y != 0 && x/y > tolerance)
	complain();
```
## 3.8 运算符&&、||和!
某些时候可以互换，但只是巧合所致
## 3.9 整数溢出
无符号算术运算中，没有所谓的“溢出”一说
```c
if ( a + b < 0)
	complain();
	
if ((unsigned)a + (unsigned)b　> INT_MAX)//INT_MAX <limits.h> ANSI C
	complain();

if ( a > INT_MAX - b)
	complain();	

```

## 3.10 为函数main提供返回值
大多数Ｃ语言实现都通过函数main的返回值来告知操作系统该函数的执行是成功还是失败
```c
#include <stdio.h>
main() {
	printf("hello world\n");
	return 0;
}
```
# 第４章　连接
某些Ｃ语言实现提供了一个成为lint的程序
## 4.1 什么是连接器
Ｃ语言中的一个重要思想就是分别编译（Separate Compilation），即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。

尽管连接器并不理解Ｃ语言，然而它却能够理解机器语言和内存布局

连接器的一个重要工作就是处理命名冲突

如果读者的Ｃ语言实现中提供了lint程序，切记要使用！
## 4.2 声明与定义
extern
## 4.3 命名冲突与static修饰符
static
## 4.4 形参、实参与返回值
如果一个函数在被定义或声明之前被调用，那么它的返回类型就默认为整数
```c
//ANSI C　支持这种较“老”形式的声明与定义
int isvowel(c)
			char c;
{
	return c == 'a' || c == 'e' || c == 'i' ||
			c == 'o' || c == 'u';
}
```
## 4.5 检查外部类型
extern int n;

long n;

大多数Ｃ语言实现不能检测出这种错误
## 4.6 头文件
一个简单的规则：每个外部对象只在一个地方声明
# 第５章　库函数
Ｃ语言中没有定义输入／输出语句，任何一个有用的Ｃ程序（起码必须接受零个或多个输入，生成一个或多个输出）都必须调用库函数来完成最基本的输入／输出函数操作。

ANSI C标准毫无疑问地意识到了这一点，因而定义了一个包含大量标准库函数的集合

* ANSI C中定义的标准库函数集合并不完备
* 并非所有的Ｃ语言实现都包括了全部的标准库函数

尽量使用系统头文件

## 5.1 返回整数的getchar函数
```c
#include <stdio.h>

main()
{
	char c;//不是int类型，无法容下所有可能的字符，特别是，可能无法容下EOF
	while((c = getchar()) != EOF)//有些编译器可能比较的是getchar函数的返回值与EOF
		puchar(c);
}
```
## 5.2 更新顺序文件
如果要同时进行输入和输出操作，必须在其中插入fseek函数的调用
## 5.3 缓冲输出与内存分配
程序输出有两种方式：

1. 及时处理
2. 暂存起来
```c
#include <stdio.h>

main()
{
	int c;
	
	//1
	static char buf[BUFSIZ];
	setbuf(stdout, buf);
	//2
	char *malloc();
	setbuf(stdout, malloc(BUFSIZ));//这里不需要检查malloc函数调用是否成功
	
	while((c = getchar()) != EOF)
		puchar(c);
}

```
## 5.4 使用errno检测错误
```c
/* 调用库函数*/
if(返回的错误值)
	检查errno
```
## 5.5 库函数signal
在许多Ｃ语言实现中，信号是真正意义上的“异步”。

从理论上说，一个信号可能在Ｃ程序期间的任何时刻上发生。

signal处理函数的唯一安全、可移植的操作就是打印一条出错消息，然后使用longjmp或exit立即退出程序

信号非常复杂棘手，而且具有一些从本质上而言不可移植的特性。

解决这个问题我们最好采取“守势”，让signal处理函数尽可能地简单，并将它们组织在一起
# 第６章　预处理器
Ｃ语言预处理器首先对程序代码作了必要的转换处理

重要性可以由两个主要的原因说明：

1. 在程序中只改动一处数值，然后重新编译就可以实现
2. 大多数Ｃ语言实现在函数调用时都会带来重大的系统开销。因此，我们也许希望有这样一种程序块，它看上去像一个函数，但却没有函数调用的开销

宏只是对程序的文本起作用，也就是说，宏提供了一种对组成Ｃ程序的字符进行变换的方式

## 6.1 不能忽视宏定义中的空格
```c
#define f(x) ((x)-1)
```
## 6.2 宏不是函数
括号的作用是预防引起与优先级有关的问题

宏展开可能产生非常庞大的表达式，占用的空间远远超过了编程者所期望的空间
## 6.3 宏不是语句
把assert作为宏来处理，这样就使得我们可以在出错信息中包括有文件名和断言失败处的行号

```c
#define assert(e) \
			((void)((e)||_assert_error(__FILE__,__LINE__)))
```
## 6.4 宏并不是类型定义
宏定义的这种用法有一个优点－－－可移植性，得到了所有Ｃ编译器的支持。

但是，我们最好还是使用类型定义：

typedef struct foo FOOTYPE;

# 第７章　可移植性缺陷
本书重点放在语言的属性上

## 7.1 应对Ｃ语言标准变更
函数声明中略去参数类型的说明，这在ANSI C标准中也是合法的

程序的生命期往往超过了编程者最初的预料，即使这个程序只是编程者出于自用的目的而编写的
## 7.2 标识符名称的限制
强制所有的外部名称必须是大写

事实上，ANSI C标准所能保证的只是，C实现必须能够区别出前６个字符不同的外部名称。而且，这个定义中并没有区分大写字母与其对应的小写字母
## 7.3 整数的大小
可移植性最好的办法就是声明该变量为long型，但在这种情况下我们定义一个“新的”类型无疑更为清晰：

typedef long tenmil;

## 7.4 字符是有符号整数还是无符号整数
如果c是一个字符常量，使用(unsigned)c，c将首先被转换为int型整数
## 7.5 移位运算符
两个问题感到困惑：

1. 在向右移位时，空出的位是由０填充，还是由符号位的副本填充？

与具体的Ｃ语言实现有关。

如果关注向右移位时空出的位，那么可以将操作的变量声明为无符号类型，那么空出的位都会被设置为０

2. 移位计数（即移位操作的位数）允许的取值范围是什么？

如果被移位的对象长度是n位，那么移位计数必须大于或等于０，而严格小于n

## 7.6 内存位置０
误用null指针的效果都是未定义的
## 7.7 除法运算时发生的截断
程序在设计时就应该避免n的值为负这样的情形，并且声明n为无符号数
## 7.8 随机数的大小
ANSI C标准中定义了一个常数RAND_MAX,它的值等于随机数的最大值
## 7.9 大小写转换
```c

//方便
#define toupper(c) ((c) >= 'a' && (c) <= 'z'? (c) + 'A' -'a': (c))
#define tolower(c) ((c) >= 'A' && (c) <= 'Z'? (c) + 'a' -'A': (c))
//速度
#define _toupper(c) ((c)+'A'-'a')
#define _tolower(c) ((c)+'a'-'A')

```
## 7.10 首先释放，然后重新分配
UNIX系统参考手册第７版中描述的realloc函数的行为，，，

这一实现允许在某内存块被释放之后重新分配其大小，前提是内存重分配（reallocation）操作执行得必须足够早
```c
free(p);
p = realloc(p, newsize);
```
不值得推荐，因为并非所有的Ｃ实现在某块内存被释放后还能较长时间的保留之

早期的realloc函数的实现要求待重新分配的内存区域必须首先被释放
## 7.11 可移植性问题的一个例子
"0123456789"[n % 10]

努力提高软件的可移植性，实际上是延长了软件的生命期

本例中的代码改动看上去是提高软件的可移植性，实际上大多数工作是确保边界条件的正确
# 第８章　建议与答案
事前周密思考
## 8.1 建议
* 不要说服自己相信“皇帝的新装”
* 直截了当地表明意图
* 考查最简单的特例
* 使用不对称边界
* 注意潜伏在暗处的ＢＵＧ
* 防御性编程
