# 第１章　词法“陷阱”
## 1.1 ＝不同于＝＝
## 1.2 &和|不同于&&和||
## 1.3 词法分析中的“贪心法”
## 1.4　整形变量
０开头，八进制
## 1.５　字符与字符串
‘’和“”
# 第２章　语法“陷阱”
必须理解这些符号是如何组合成声明、表达式、语句和程序的
## 2.1 理解函数声明
```c
(*(void(*)())0)();

typedef void (*funcptr)();
(*(funcptr)0)();

void (*singnal(int, void(*)(int)))(int);

typedef void (*HANDLER)(int);
HANDLER singal(int, HANDLER);

```
## 2.2 运算符的优先级问题
* 非真正意义运算符
* 单目
* 双目（算术、移位、关系、逻辑，赋值、条件）
* 三目
* 赋值
* 逗号

## 2.3 注意作为语句结束标志的分号
多写，少写
## 2.4 switch语句
break，或有意略去
## 2.5 函数调用
不带参数也该有参数列表，否则只是计算地址
## 2.6 “悬挂”else引发的问题
else始终与同一括号内最近的未匹配的if结合
# 第３章　语义“陷阱”
语法歧义
## 3.1 指针与数组
* 只有一维数组，且数组大小必须在编译器就作为一个常数确定下来
* 只能做两件事：确定大小，获取[0]指针
* 指针＋整数，与该指针的二进制＋整数，含义不同
* int (*ap)[31];

## 3.2 非数组的指针
以空字符串('\0')作为结束标志
```c
char *r, *malloc();
r = malloc(strlen(s) + strlen(t) + 1);
if(!r) {
	complain();
	exit(1);
}
strcpy(r, s);
strcat(r, t);
```
## 3.3 作为参数的数组声明
无法将数组作为函数参数直接传递
## 3.4 避免“举隅法”
复制指针并不同时复制指针所指向的数据
## 3.5 空指针并非空字符串
```c
if (p == (char *)0) ...// OK

if (strcmp(p, (char *) == 0) ... // ERROR
```
## 3.6 边界计算与不对称边界
10个元素数组，不存在下标为10的元素

避免"栏杆错误"的两个通用原则
1. 首先考虑最简单情况下的特例，然后将得到的结果外推
2. 仔细计算边界，绝不掉以轻心

ANSI　C标准明确允许这种用法:数组中实际不存在的"溢界"元素的地址位于数组所占内存之后，这个地址可以用于进行赋值和比较。当然，如果要引用该元素，那就是非法的了

## 3.7 求值顺序
```c
if (y != 0 && x/y > tolerance)
	complain();
```
## 3.8 运算符&&、||和!
某些时候可以互换，但只是巧合所致
## 3.9 整数溢出
无符号算术运算中，没有所谓的“溢出”一说
```c
if ( a + b < 0)
	complain();
	
if ((unsigned)a + (unsigned)b　> INT_MAX)//INT_MAX <limits.h> ANSI C
	complain();

if ( a > INT_MAX - b)
	complain();	

```

## 3.10 为函数main提供返回值
大多数Ｃ语言实现都通过函数main的返回值来告知操作系统该函数的执行是成功还是失败
```c
#include <stdio.h>
main() {
	printf("hello world\n");
	return 0;
}
```
# 第４章　连接
## 4.1 什么是连接器
## 4.2 声明与定义
## 4.3 命名冲突与static修饰符
## 4.4 形参、实参与返回值
## 4.5 检查外部类型
## 4.6 头文件

# 第５章　库函数
## 5.1 返回整数的getchar函数
## 5.2 更新顺序文件
## 5.3 缓冲输出与内存分配
## 5.4 使用errno检测错误
## 5.5 库函数signal

# 第６章　预处理器
## 6.1 不能忽视宏定义中的空格
## 6.2 宏不是函数
## 6.3 宏不是语句
## 6.4 宏并不是类型定义

# 第７章　可移植性缺陷
## 7.1 应对Ｃ语言标准变更
## 7.2 标识符名称的限制
## 7.3 整数的大小
## 7.4 字符是有符号整数还是无符号整数
## 7.5 移位运算符
## 7.6 内存位置０
## 7.7 除法运算时发生的截断
## 7.8 随机数的大小
## 7.9 大小写转换
## 7.10 首先释放，然后重新分配
## 7.11 可移植性问题的一个例子

# 第８章　建议与答案
## 8.1 建议
